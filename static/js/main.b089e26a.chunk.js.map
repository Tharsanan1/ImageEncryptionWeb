{"version":3,"sources":["components/Canvas.jsx","components/ImageSelectorAndContainer.jsx","App.js","serviceWorker.js","index.js"],"names":["encrypt","imageData","ctx","rotateFunction","encryptionKey","imgData","x","y","r","g","b","a","random","SeedRandom","index","data","length","randomNum","Math","floor","colorData","getPixel","width","i","d","setPixel","putImageData","alert","Canvas","props","state","height","downloadAll","encryptAll","decryptAll","fixedSize","inProgress","canvas","React","createRef","image","decryptClicked","bind","encryptClicked","downloadImage","console","log","this","current","getContext","clearRect","img","onload","imageFile","setState","drawImage","getImageData","source","diff","leftRotate","rotatedVal","rightRotate","e","lnk","document","createElement","download","href","toDataURL","createEvent","initMouseEvent","window","dispatchEvent","fireEvent","className","style","margin","backgroundColor","onClick","CircularProgress","maxWidth","maxHeight","overflow","ref","src","display","Component","ImageSelectorAndContainer","color","canvasData","handleChange","publishTaskClicked","handleInputChangeEncryptionKey","event","target","files","push","key","URL","createObjectURL","value","taskNum","borderStyle","borderColor","type","marginBottom","class","placeholder","aria-label","aria-describedby","onChange","id","multiple","for","flexDirection","map","element","App","Boolean","location","hostname","match","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"uRAIA,SAASA,EAAQC,EAAWC,EAAKC,EAAgBC,GAC7C,GAAqB,KAAlBA,EAAH,CAOA,IAHA,IA6EgBC,EAASC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EA7EpCC,EAASC,IAAWT,GAGfU,EAAQ,EAAGA,EAAQb,EAAUc,KAAKC,OAAS,EAAGF,IAAS,CAC5D,IAAIG,EAAY,kBAAMC,KAAKC,MAAY,IAANP,KAF3B,GAGFQ,EAAYC,EAASpB,EAAWa,GACpCM,EAAU,GAAKjB,EAAeiB,EAAU,GAAIH,KAC5CG,EAAU,GAAKjB,EAAeiB,EAAU,GAAIH,KAC5CG,EAAU,GAAKjB,EAAeiB,EAAU,GAAIH,KAqEhCZ,EApEDJ,EAoEUK,EApECY,KAAKC,MAAML,EAAQb,EAAUqB,OAoE3Bf,EApEmCW,KAAKC,MAAML,EAAQb,EAAUqB,OAoE7Dd,EApEqEY,EAAU,GAoE5EX,EApEgFW,EAAU,GAoEvFV,EApE2FU,EAAU,GAoElGT,EApEsG,IA4DlJ,SAAkBN,EAASS,EAAON,EAAGC,EAAGC,EAAGC,GACvC,IAAIY,EAAY,EAART,EAAWU,EAAInB,EAAQU,KAC/BS,EAAED,GAAKf,EACPgB,EAAED,EAAI,GAAKd,EACXe,EAAED,EAAI,GAAKb,EACXc,EAAED,EAAI,GAAKZ,EAIJc,CAASpB,EAASE,EAAIF,EAAQiB,MAAQhB,EAAGE,EAAGC,EAAGC,EAAGC,GAnEzDT,EAAIwB,aAAazB,EAAW,EAAG,QAd3B0B,MAAM,mCA+Dd,SAASN,EAAShB,EAASS,GACvB,IAAIS,EAAY,EAART,EAAWU,EAAInB,EAAQU,KAC/B,MAAO,CAACS,EAAED,GAAIC,EAAED,EAAI,GAAIC,EAAED,EAAI,GAAIC,EAAED,EAAI,I,IAiJ7BK,E,kDA5HX,WAAYC,GAAQ,IAAD,8BACf,cAAMA,IACDC,MAAQ,CACTR,MAAO,EACPS,OAAQ,EACRC,YAAa,EACbC,WAAY,EACZC,WAAY,EACZC,UAAY,QACZC,YAAa,GAEjB,EAAKC,OAASC,IAAMC,YACpB,EAAKC,MAAQF,IAAMC,YACnB,EAAKE,eAAiB,EAAKA,eAAeC,KAApB,gBACtB,EAAKC,eAAiB,EAAKA,eAAeD,KAApB,gBACtB,EAAKE,cAAgB,EAAKA,cAAcF,KAAnB,gBAfN,E,gEAoCE,IAAD,OAChBG,QAAQC,IAAI,gBACZ,IAAMT,EAASU,KAAKV,OAAOW,QACrB9C,EAAMmC,EAAOY,WAAW,MAC9B/C,EAAIgD,UAAU,EAAG,EAAGb,EAAOf,MAAOe,EAAON,QACzC,IAAMoB,EAAMJ,KAAKP,MAAMQ,QACvBG,EAAIC,OAAS,WACTP,QAAQC,IAAI,EAAKjB,MAAMwB,WACvB,EAAKC,SAAS,CACVhC,MAAO6B,EAAI7B,MACXS,OAAQoB,EAAIpB,SACb,WACC7B,EAAIqD,UAAUJ,EAAK,EAAG,S,uCAMhB,IAAD,OACbJ,KAAKO,SAAS,CAAClB,YAAW,IACtB,WACI,IACMlC,EADS,EAAKmC,OAAOW,QACRC,WAAW,MAE9BjD,EADgBE,EAAIsD,aAAa,EAAG,EAAG,EAAK1B,MAAMR,MAAO,EAAKQ,MAAMC,QACjD7B,GAAK,SAACuD,EAAQC,GAC7B,OArHpB,SAAoBD,EAAQC,GAExB,OAAID,GAAUC,EACHD,EAASC,EAFH,KAKQA,EAAOD,GA+GTE,CAAWF,EAAQC,KAC3B,EAAK7B,MAAMzB,eACd,EAAKkD,SAAS,CAAClB,YAAW,S,uCAIpB,IAAD,OACbW,KAAKO,SAAS,CAAClB,YAAW,IACtB,WACI,IACMlC,EADS,EAAKmC,OAAOW,QACRC,WAAW,MAE9BjD,EADgBE,EAAIsD,aAAa,EAAG,EAAG,EAAK1B,MAAMR,MAAO,EAAKQ,MAAMC,QACjD7B,GAAK,SAACuD,EAAQC,GAC7B,OA3IpB,SAAqBD,EAAQC,GACzB,IACIE,GAAcH,EAASC,GADV,IAKjB,OAHIE,EAAa,GAAKA,EAAa,MAC/BjC,MAAM,UAEF8B,EAASC,GALA,IA0IMG,CAAYJ,EAAQC,KAC5B,EAAK7B,MAAMzB,eACd,EAAKkD,SAAS,CAAClB,YAAW,S,sCAMlC,IAAuC0B,EAAnCC,EAAMC,SAASC,cAAc,KAGjCF,EAAIG,SAAW,WAKfH,EAAII,KAAOpB,KAAKV,OAAOW,QAAQoB,UAAU,oBAGrCJ,SAASK,cACTP,EAAIE,SAASK,YAAY,gBACvBC,eAAe,SAAS,GAAM,EAAMC,OAClC,EAAG,EAAG,EAAG,EAAG,GAAG,GAAO,GAAO,GAC7B,EAAO,EAAG,MAEdR,EAAIS,cAAcV,IACXC,EAAIU,WACXV,EAAIU,UAAU,a,+BAIZ,IAAD,OACL,OACI,yBAAKC,UAAU,OAAOC,MAAO,CAAEC,OAAQ,OAAQC,gBAAiB,YAC5D,yBAAKH,UAAU,aACX,4BAAQC,MAAO,CAAEC,OAAQ,QAAUF,UAAU,kBAAkBI,QAAS,kBAAM,EAAKlC,kBAAnF,YACA,4BAAQ+B,MAAO,CAAEC,OAAQ,QAAUF,UAAU,iBAAiBI,QAAS,kBAAM,EAAKnC,mBAAlF,WACA,4BAAQgC,MAAO,CAAEC,OAAQ,QAAUF,UAAU,kBAAkBI,QAAS,kBAAM,EAAKrC,mBAAnF,WACA,8BACyB,IAAxBM,KAAKjB,MAAMM,WAAkB,kBAAC2C,EAAA,EAAD,MAAqB,+BAEnD,yBAAKJ,MAAO,CAAErD,MAAOyB,KAAKjB,MAAMK,UAAW6C,SAAUjC,KAAKjB,MAAMK,UAAWJ,OAAQgB,KAAKjB,MAAMK,UAAW8C,UAAWlC,KAAKjB,MAAMK,UAAW+C,SAAU,WAChJ,4BAAQC,IAAKpC,KAAKV,OAAQf,MAAOyB,KAAKjB,MAAMR,MAAOS,OAAQgB,KAAKjB,MAAMC,UAE1E,yBAAKoD,IAAKpC,KAAKP,MAAO4C,IAAKrC,KAAKlB,MAAMwB,UAAWsB,MAAO,CAAEU,QAAS,gB,GAxHlE/C,IAAMgD,WCoBZC,E,kDAtGb,WAAY1D,GAAQ,IAAD,8BACjB,cAAMA,IACDC,MAAQ,CACX0D,MAAO,UACPC,WAAY,GACZzD,YAAa,EACbC,WAAY,EACZC,WAAY,EACZmB,UAAW,GACXjD,cAAe,IAEjB,EAAKsF,aAAe,EAAKA,aAAahD,KAAlB,gBACpB,EAAKiD,mBAAqB,EAAKA,mBAAmBjD,KAAxB,gBAC1B,EAAKkD,+BAAiC,EAAKA,+BAA+BlD,KAApC,gBAbrB,E,yDAgBNmD,GACX,GAAgC,IAA5B9C,KAAKjB,MAAM1B,cACbuB,MAAM,mEAIN,GADAkB,QAAQC,IAAI+C,EAAMC,OAAOC,OACrBF,EAAMC,OAAOC,MAAM/E,OAAS,EAAG,CAEjC,IADA,IAAIyE,EAAa,GACR3E,EAAQ,EAAGA,EAAQ+E,EAAMC,OAAOC,MAAM/E,OAAQF,IACrD2E,EAAWO,KAAK,CACdC,IAAKnF,EACLuC,UAAW6C,IAAIC,gBAAgBN,EAAMC,OAAOC,MAAMjF,MAItDiC,KAAKO,SAAS,CACZmC,WAAYA,IAIlBI,EAAMC,OAAOM,MAAQ,O,yCAGJC,M,qDAqBYvC,GAC7BjB,QAAQC,IAAIgB,GACZf,KAAKO,SAAS,CAAElD,cAAe0D,EAAEgC,OAAOM,U,+BAIhC,IAAD,OACP,OACE,yBAAKzB,MAAO,CAAE2B,YAAa,QAASC,YAAaxD,KAAKjB,MAAM0D,MAAOX,gBAAiB,YAClF,yBAAKF,MAAO,CAAEC,OAAQ,SACpB,2BAAO4B,KAAK,OAAO7B,MAAO,CAAE8B,aAAc,QAAUC,MAAM,eAAeC,YAAY,gBAAgBC,aAAW,uBAAuBC,mBAAiB,eAAeT,MAAOrD,KAAKjB,MAAM1B,cAAe0G,SAAU/D,KAAK6C,iCAEvN,yBAAKc,MAAM,eACT,yBAAKA,MAAM,uBACT,0BAAMA,MAAM,mBAAmBK,GAAG,yBAAlC,WAEF,yBAAKL,MAAM,eACT,2BAAOF,KAAK,OAAOE,MAAM,oBAAoBK,GAAG,mBAC9CF,mBAAiB,wBAAwBG,SAAS,WAAWF,SAAU/D,KAAK2C,eAC9E,2BAAOgB,MAAM,oBAAoBO,IAAI,oBAArC,wBAKJ,yBAAKtC,MAAO,CAAEU,QAAS,OAAQ6B,cAAe,QAC5C,6BACGnE,KAAKjB,MAAM2D,WAAW0B,KACrB,SAACC,GACC,OAAO,kBAAC,EAAD,CAAQnB,IAAKmB,EAAQnB,IAAK5C,UAAW+D,EAAQ/D,UAAWrB,YAAa,EAAKF,MAAME,YAAaC,WAAY,EAAKH,MAAMG,WAAYC,WAAY,EAAKJ,MAAMI,WAAY9B,cAAe,EAAK0B,MAAM1B,2B,GAzF9KkC,IAAMgD,WCI/B+B,MARf,WACE,OACE,yBAAK3C,UAAU,OACb,kBAAC,EAAD,QCMc4C,QACW,cAA7B/C,OAAOgD,SAASC,UAEe,UAA7BjD,OAAOgD,SAASC,UAEhBjD,OAAOgD,SAASC,SAASC,MACvB,2DCbNC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEF5D,SAAS6D,eAAe,SD0HpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLxF,QAAQwF,MAAMA,EAAMC,c","file":"static/js/main.b089e26a.chunk.js","sourcesContent":["import React from \"react\";\nimport SeedRandom from \"seedrandom\";\nimport CircularProgress from '@material-ui/core/CircularProgress';\n\nfunction encrypt(imageData, ctx, rotateFunction, encryptionKey) {\n    if(encryptionKey === \"\"){\n        alert(\"Please provide a encryption key\");\n        return;\n    }\n    let random = SeedRandom(encryptionKey);\n    let max = 257;\n    let min = 0;\n    for (let index = 0; index < imageData.data.length / 4; index++) {\n        let randomNum = () => Math.floor(random() * (max - min)) + min;\n        let colorData = getPixel(imageData, index);\n        colorData[0] = rotateFunction(colorData[0], randomNum());\n        colorData[1] = rotateFunction(colorData[1], randomNum());\n        colorData[2] = rotateFunction(colorData[2], randomNum());\n        setPixelXY(imageData, Math.floor(index % imageData.width), Math.floor(index / imageData.width), colorData[0], colorData[1], colorData[2], 255);\n    }\n    ctx.putImageData(imageData, 0, 0);\n\n}\n\n\nlet count = 0;\n\nfunction rightRotate(source, diff) {\n    let circleSize = 256;\n    let rotatedVal = (source + diff) % circleSize;\n    if (rotatedVal < 0 || rotatedVal > 255) {\n        alert(\"wrong\");\n    }\n    return (source + diff) % circleSize;\n}\n\nfunction leftRotate(source, diff) {\n    let circleSize = 256;\n    if (source >= diff) {\n        return source - diff;\n    }\n    else {\n        return circleSize - (diff - source);\n    }\n}\n// function delayedWipe(imageData, ctx) {\n//     setTimeout(() => {\n//         if (count < imageData.data.length / 4) {\n//             let index = count;\n//             let start = index;\n//             let factor = 1;\n//             let temp = imageData.width * factor;\n//             while (temp > 0) {\n//                 count++;\n//                 setPixelXY(imageData, Math.floor(index % imageData.width), Math.floor(index / imageData.width), 255, 127, 0, 255);\n//                 index++\n//                 temp--;\n//             }\n//             index = start;\n//             ctx.putImageData(imageData, 0, 0, Math.floor(index % imageData.width), Math.floor(index / imageData.width), imageData.width, factor);\n//             delayedWipe(imageData, ctx);\n//         }\n//         else {\n//             ctx.putImageData(imageData, 0, 0);\n//         }\n//     }, 1);\n// }\n\n\nfunction getPixel(imgData, index) {\n    var i = index * 4, d = imgData.data;\n    return [d[i], d[i + 1], d[i + 2], d[i + 3]] // [R,G,B,A]\n}\n\nfunction getPixelXY(imgData, x, y) {\n    return getPixel(imgData, y * imgData.width + x);\n}\n\nfunction setPixel(imgData, index, r, g, b, a) {\n    var i = index * 4, d = imgData.data;\n    d[i] = r;\n    d[i + 1] = g;\n    d[i + 2] = b;\n    d[i + 3] = a;\n}\n\nfunction setPixelXY(imgData, x, y, r, g, b, a) {\n    return setPixel(imgData, y * imgData.width + x, r, g, b, a);\n}\n\nclass Canvas extends React.Component {\n\n    constructor(props) {\n        super(props);\n        this.state = {\n            width: 0,\n            height: 0,\n            downloadAll: 0,\n            encryptAll: 0,\n            decryptAll: 0,\n            fixedSize : \"500px\",\n            inProgress : false\n        };\n        this.canvas = React.createRef();\n        this.image = React.createRef();\n        this.decryptClicked = this.decryptClicked.bind(this);\n        this.encryptClicked = this.encryptClicked.bind(this);\n        this.downloadImage = this.downloadImage.bind(this);\n    }\n\n    // componentDidUpdate() {\n    //     console.log(\"did update : \");\n    //     const canvas = this.canvas.current;\n    //     const ctx = canvas.getContext(\"2d\");\n    //     ctx.clearRect(0, 0, canvas.width, canvas.height);\n    //     const img = this.image.current;\n    //     img.onload = () => {\n    //         console.log(this.props.imageFile);\n    //         this.setState({\n    //             width: img.width,\n    //             height: img.height\n    //         }, () => {\n    //             ctx.drawImage(img, 0, 0);\n\n    //         })\n    //     }\n    // }\n\n    componentDidMount() {\n        console.log(\"did mount : \");\n        const canvas = this.canvas.current;\n        const ctx = canvas.getContext(\"2d\");\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        const img = this.image.current;\n        img.onload = () => {\n            console.log(this.props.imageFile);\n            this.setState({\n                width: img.width,\n                height: img.height\n            }, () => {\n                ctx.drawImage(img, 0, 0);\n\n            })\n        }\n    }\n\n    decryptClicked() {\n        this.setState({inProgress:true},\n            () => {\n                const canvas = this.canvas.current;\n                const ctx = canvas.getContext(\"2d\");\n                let imageData = ctx.getImageData(0, 0, this.state.width, this.state.height);\n                encrypt(imageData, ctx, (source, diff) => {\n                    return leftRotate(source, diff);\n                }, this.props.encryptionKey);\n                this.setState({inProgress:false})\n            })\n    }\n\n    encryptClicked() {\n        this.setState({inProgress:true},\n            () => {\n                const canvas = this.canvas.current;\n                const ctx = canvas.getContext(\"2d\");\n                let imageData = ctx.getImageData(0, 0, this.state.width, this.state.height);\n                encrypt(imageData, ctx, (source, diff) => {\n                    return rightRotate(source, diff);\n                }, this.props.encryptionKey);\n                this.setState({inProgress:false})\n            })\n        \n    }\n\n    downloadImage() {\n        var lnk = document.createElement('a'), e;\n\n        /// the key here is to set the download attribute of the a tag\n        lnk.download = \"filename\";\n\n        /// convert canvas content to data-uri for link. When download\n        /// attribute is set the content pointed to by link will be\n        /// pushed as \"download\" in HTML5 capable browsers\n        lnk.href = this.canvas.current.toDataURL(\"image/png;base64\");\n\n        /// create a \"fake\" click-event to trigger the download\n        if (document.createEvent) {\n            e = document.createEvent(\"MouseEvents\");\n            e.initMouseEvent(\"click\", true, true, window,\n                0, 0, 0, 0, 0, false, false, false,\n                false, 0, null);\n\n            lnk.dispatchEvent(e);\n        } else if (lnk.fireEvent) {\n            lnk.fireEvent(\"onclick\");\n        }\n    }\n\n    render() {\n        return (\n            <div className=\"card\" style={{ margin: \"20px\", backgroundColor: \"#ffffff\" }}>\n                <div className=\"card-body\">\n                    <button style={{ margin: \"20px\" }} className=\"btn btn-primary\" onClick={() => this.downloadImage()}>download</button>\n                    <button style={{ margin: \"20px\" }} className=\"btn btn-danger\" onClick={() => this.encryptClicked()}>encrypt</button>\n                    <button style={{ margin: \"20px\" }} className=\"btn btn-success\" onClick={() => this.decryptClicked()}>decrypt</button>\n                    <div >\n                    {this.state.inProgress===true?<CircularProgress />:<div/>}\n    </div>\n                    <div style={{ width: this.state.fixedSize, maxWidth: this.state.fixedSize, height: this.state.fixedSize, maxHeight: this.state.fixedSize, overflow: \"scroll\" }}>\n                        <canvas ref={this.canvas} width={this.state.width} height={this.state.height} />\n                    </div>\n                    <img ref={this.image} src={this.props.imageFile} style={{ display: \"none\" }} />\n                </div>\n            </div>\n        )\n    }\n}\nexport default Canvas","import React from \"react\";\nimport Canvas from \"./Canvas\";\n\nconst downloadAll = 1;\nconst encryptAll = 2;\nconst decryptAll = 3;\n\nclass ImageSelectorAndContainer extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      color: \"#ffffff\",\n      canvasData: [],\n      downloadAll: 0,\n      encryptAll: 0,\n      decryptAll: 0,\n      imageFile: \"\",\n      encryptionKey: \"\"\n    }\n    this.handleChange = this.handleChange.bind(this)\n    this.publishTaskClicked = this.publishTaskClicked.bind(this);\n    this.handleInputChangeEncryptionKey = this.handleInputChangeEncryptionKey.bind(this);\n  }\n\n  handleChange(event) {\n    if (this.state.encryptionKey == \"\") {\n      alert(\"Please enter the encryption key before select your images.\");\n    }\n    else {\n      console.log(event.target.files)\n      if (event.target.files.length > 0) {\n        let canvasData = [];\n        for (let index = 0; index < event.target.files.length; index++) {\n          canvasData.push({\n            key: index,\n            imageFile: URL.createObjectURL(event.target.files[index]),\n          });\n\n        }\n        this.setState({\n          canvasData: canvasData\n        })\n      }\n    }\n    event.target.value = null;\n  }\n\n  publishTaskClicked(taskNum) {\n    // switch (taskNum) {\n    //   case downloadAll:\n    //     console.log(\"downoad\");\n    //     this.setState({\n    //       downloadAll: this.state.downloadAll + 1,\n    //     })\n    //     break;\n    //   case encryptAll:\n    //     this.setState({\n    //       encryptAll: this.state.encryptAll + 1\n    //     })\n    //     break;\n    //   case decryptAll:\n    //     this.setState({\n    //       decryptAll: this.state.decryptAll + 1\n    //     })\n    //     break;\n    // }\n  }\n\n  handleInputChangeEncryptionKey(e) {\n    console.log(e);\n    this.setState({ encryptionKey: e.target.value });\n  }\n\n\n  render() {\n    return (\n      <div style={{ borderStyle: \"solid\", borderColor: this.state.color, backgroundColor: \"#ffffff\" }}>\n        <div style={{ margin: \"20px\" }}>\n          <input type=\"text\" style={{ marginBottom: \"20px\" }} class=\"form-control\" placeholder=\"Encryptio Key\" aria-label=\"Recipient's username\" aria-describedby=\"basic-addon2\" value={this.state.encryptionKey} onChange={this.handleInputChangeEncryptionKey} />\n\n          <div class=\"input-group\">\n            <div class=\"input-group-prepend\">\n              <span class=\"input-group-text\" id=\"inputGroupFileAddon01\">Upload</span>\n            </div>\n            <div class=\"custom-file\">\n              <input type=\"file\" class=\"custom-file-input\" id=\"inputGroupFile01\"\n                aria-describedby=\"inputGroupFileAddon01\" multiple=\"multiple\" onChange={this.handleChange} />\n              <label class=\"custom-file-label\" for=\"inputGroupFile01\">Choose image files</label>\n            </div>\n          </div>\n\n\n          <div style={{ display: \"flex\", flexDirection: \"row\" }}>\n            <div>\n              {this.state.canvasData.map(\n                (element) => {\n                  return <Canvas key={element.key} imageFile={element.imageFile} downloadAll={this.state.downloadAll} encryptAll={this.state.encryptAll} decryptAll={this.state.decryptAll} encryptionKey={this.state.encryptionKey} />\n                }\n              )}\n            </div>\n          </div>\n        </div>\n      </div>\n\n\n\n    );\n  }\n}\n\nexport default ImageSelectorAndContainer;","import React from 'react';\nimport ImageContainer from \"./components/ImageSelectorAndContainer\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <ImageContainer/>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}